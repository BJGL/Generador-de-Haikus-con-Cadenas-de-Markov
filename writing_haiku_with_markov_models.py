# -*- coding: utf-8 -*-
"""Writing Haiku with Markov Models

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dcMaHCbKyMewSKWBSSrXt8TomL7FYNFL
"""

import sys
import logging
import random
from collections import defaultdict

# --- FUNCIÓN AUXILIAR PARA SÍLABAS ---
# (La incluyo aquí por si no tienes la librería externa instalada)
def count_syllables(word):
    word = word.lower()
    count = 0
    vowels = "aeiouyáéíóúü"
    if len(word) == 0: return 0
    if word[0] in vowels: count += 1
    for index in range(1, len(word)):
        if word[index] in vowels and word[index - 1] not in vowels:
            count += 1
    if word.endswith("e"): count -= 1
    if count == 0: count += 1
    return count
# -------------------------------------

logging.disable(logging.CRITICAL)
logging.basicConfig(level=logging.DEBUG, format='%(message)s')

def cargar_archivo_entrenamiento(archivo):
    """ Devuelve el archivo de texto como una cadena (string) """
    try:
        with open(archivo, encoding='utf-8') as f:
            haiku_crudo = f.read()
            return haiku_crudo
    except FileNotFoundError:
        print(f"Error: No se encontró el archivo '{archivo}'. Asegúrate de que existe.")
        sys.exit()

def preparar_entrenamiento(haiku_crudo):
    """ Carga la cadena, elimina saltos de línea, divide por espacios y devuelve lista """
    corpus = haiku_crudo.replace('\n', ' ').split()
    return corpus

def mapear_palabra_a_palabra(corpus):
    limite = len(corpus)
    dicc_1_a_1 = defaultdict(list)

    for indice, palabra in enumerate(corpus):
        if indice < limite - 1:
            sufijo = corpus[indice+1]
            dicc_1_a_1[palabra].append(sufijo)

    logging.debug('resultados de mapear_palabra_a_palabra para \'sake\' = %s\n', dicc_1_a_1.get('sake'))
    return dicc_1_a_1

def mapear_2_palabras_a_palabra(corpus):
    # Esta función se mantiene por compatibilidad, pero ya no la usaremos para generar
    # para evitar que el texto se repita demasiado.
    limite = len(corpus) - 2
    dicc_2_a_1 = defaultdict(list)

    for indice, palabra in enumerate(corpus):
        if indice < limite:
            clave = palabra + ' ' + corpus[indice+1]
            sufijo = corpus[indice+2]
            dicc_2_a_1[clave].append(sufijo)

    logging.debug('resultados de mapear_2_palabras_a_palabra para \'sake jug\' = %s\n', dicc_2_a_1.get('sake jug'))
    return dicc_2_a_1

def palabra_aleatoria(corpus):
    """ Devuelve una palabra aleatoria y su conteo de sílabas del corpus de entrenamiento """
    palabra = random.choice(corpus)
    num_silabas = count_syllables(palabra)
    if num_silabas > 4:
        return palabra_aleatoria(corpus)
    else:
        logging.debug('palabra aleatoria y sílabas = %s %s\n', palabra, num_silabas)
        return (palabra, num_silabas)

def palabra_despues_una(prefijo, mapa_sufijos_1, silabas_actuales, silabas_objetivo):
    """ Devuelve todas las palabras aceptables en un corpus que siguen a una sola palabra """
    palabras_aceptadas = []
    sufijos = mapa_sufijos_1.get(prefijo)
    if sufijos is not None:
        for candidato in sufijos:
            num_silabas = count_syllables(candidato)
            if silabas_actuales + num_silabas <= silabas_objetivo:
                palabras_aceptadas.append(candidato)

    logging.debug('palabras aceptadas después de \'%s\' = %s\n', prefijo, set(palabras_aceptadas))
    return palabras_aceptadas

def linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev, silabas_objetivo):
    """ Construye una línea de Haiku desde un corpus de entrenamiento y la devuelve """

    linea = '2/3'
    silabas_linea = 0
    linea_actual = []

    # --- INICIO DE LÍNEA ---
    if len(fin_linea_prev) == 0:
        linea = '1'
        palabra, num_silabas = palabra_aleatoria(corpus)
        silabas_linea += num_silabas
        linea_actual.append(palabra)

        opciones_palabras = palabra_despues_una(palabra, mapa_sufijos_1, silabas_linea, silabas_objetivo)

        while len(opciones_palabras) == 0:
            prefijo = random.choice(corpus)
            logging.debug('nuevo prefijo aleatorio = %s', prefijo)
            opciones_palabras = palabra_despues_una(prefijo, mapa_sufijos_1, silabas_linea, silabas_objetivo)

        palabra = random.choice(opciones_palabras)
        num_silabas = count_syllables(palabra)
        logging.debug('palabra y sílabas = %s %s', palabra, num_silabas)
        silabas_linea += num_silabas
        linea_actual.append(palabra)

        if silabas_linea == silabas_objetivo:
            fin_linea_prev.extend(linea_actual[-2:])
            return linea_actual, fin_linea_prev
    else:
        linea_actual.extend(fin_linea_prev)
        # Recalcular sílabas de lo que ya traemos (para que cuadre la cuenta)
        for p in fin_linea_prev:
             silabas_linea += count_syllables(p) # Estimación simple si venimos de otra línea

    # --- RELLENO DE LÍNEA ---
    while True:
        logging.debug('linea = %s\n', linea)

        # MODIFICACIÓN CLAVE:
        # Usamos SIEMPRE la lógica de 1 palabra para forzar creatividad.
        prefijo = linea_actual[-1]
        opciones_palabras = palabra_despues_una(prefijo, mapa_sufijos_1, silabas_linea, silabas_objetivo)

        # Si nos quedamos sin opciones, intentamos salir o reiniciar (aquí rompemos para evitar bloqueo)
        if not opciones_palabras:
             break

        palabra = random.choice(opciones_palabras)
        num_silabas = count_syllables(palabra)
        logging.debug('palabra y sílabas = %s %s', palabra, num_silabas)

        if silabas_linea + num_silabas > silabas_objetivo:
            # Si nos pasamos, intentamos otra palabra del loop
            continue
        elif silabas_linea + num_silabas < silabas_objetivo:
            linea_actual.append(palabra)
            silabas_linea += num_silabas
        elif silabas_linea + num_silabas == silabas_objetivo:
            linea_actual.append(palabra)
            break

    fin_linea_prev = []
    if len(linea_actual) >= 2:
        fin_linea_prev.extend(linea_actual[-2:])
    else:
        fin_linea_prev.extend(linea_actual)

    if linea == '1':
        linea_final = linea_actual[:]
    else:
        # Si veníamos de otra línea, quitamos las palabras 'puente' que usamos para conectar
        # (Si la línea previa tenía 2 palabras, cortamos 2. Si tenía menos, ajustamos)
        corte = 2 if len(linea_actual) > 2 else 0
        linea_final = linea_actual[corte:]

    return linea_final, fin_linea_prev

def main():
    intro = """\n
    Mil monos en mil máquinas de escribir...
    o una computadora... a veces pueden producir un haiku.\n"""

    print('{}'.format(intro))

    # Asegúrate de que 'train.txt' está en la misma carpeta
    haiku_crudo = cargar_archivo_entrenamiento('train.txt')
    corpus = preparar_entrenamiento(haiku_crudo)
    mapa_sufijos_1 = mapear_palabra_a_palabra(corpus)
    mapa_sufijos_2 = mapear_2_palabras_a_palabra(corpus)
    final = []

    eleccion = None
    while eleccion != '0':
        print(
            """
            Generador de Haiku Japonés

            0 - Salir
            1 - Generar un Haiku
            2 - Regenerar Línea 2
            3 - Regenerar Línea 3
            """
        )

        eleccion = input('Elección: ')
        print()

        if eleccion == '0':
            print('Adiós')
            sys.exit()

        elif eleccion == '1':
            final = []
            fin_linea_prev = []
            primera_linea, fin_linea_prev1 = linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev, 5)
            final.append(primera_linea)

            linea, fin_linea_prev2 = linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev1, 7)
            final.append(linea)

            linea, fin_linea_prev3 = linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev2, 5)
            final.append(linea)

        elif eleccion == '2':
            if not final:
                print('Por favor, genera un haiku completo primero (Opción 1).')
                continue
            else:
                fin_linea_prev1 = final[0][-2:]
                linea, fin_linea_prev2 = linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev1, 7)
                final[1] = linea

        elif eleccion == '3':
            if not final:
                print('Por favor, genera un haiku completo primero (Opción 1).')
                continue
            else:
                fin_linea_prev2 = final[1][-2:]
                linea, fin_linea_prev3 = linea_haiku(mapa_sufijos_1, mapa_sufijos_2, corpus, fin_linea_prev2, 5)
                final[2] = linea
        else:
            print("Lo siento, pero esa no es una elección válida.", file=sys.stderr)
            continue

        print()
        print("Primera línea = ", end="")
        print(' '.join(final[0]), file=sys.stderr)
        print("Segunda línea =",end="")
        print(" ".join(final[1]), file=sys.stderr)
        print("Tercera línea = ", end="")
        print(" ".join(final[2]), file=sys.stderr)
        print()
        input("\n\nPresiona la tecla Enter para continuar.")

if __name__ == '__main__':
    main()